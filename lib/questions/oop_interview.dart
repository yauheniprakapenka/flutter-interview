import '../model/qa_model.dart';

const List<QA> oopQuestions = [
  QA(
    tags: [Tag.oop],
    q: 'Что такое ООП и какие основные принципы оно включает?',
    a: 'ООП (объектно-ориентированное программирование) — парадигма, основанная на использовании объектов. Основные принципы: инкапсуляция, наследование, полиморфизм и абстракция.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое инкапсуляция?',
    a: '''
Две основные функции инкапсуляции:
1. Объединение данных и методов
2. Сокрытие данных и контроль доступа

Инкапсуляция реализуется с помощью модификаторов доступа (например, private, protected, public), геттеров и сеттеров.
    ''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое наследование?',
    a: 'Наследование — это механизм, позволяющий создавать новый класс на основе существующего. Пример: class Dog extends Animal { ... }. Dog наследует все свойства и методы от Animal.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое полиморфизм?',
    a: 'Полиморфизм — это способность объектов разных классов обрабатывать вызовы одного и того же метода по-разному.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Можно ли создать экземпляр абстрактного класса?',
    a: 'Напрямую создать экземпляр нельзя, так как у абстрактного класса может не быть реализации методов.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Чем отличаются класс и объект?',
    a: 'Класс — это шаблон (чертеж), описывающий структуру и поведение объектов. Объект — конкретный экземпляр класса, занимающий память и способный выполнять действия.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое конструктор?',
    a: 'Конструктор — это специальный метод класса, который автоматически вызывается при создании экземпляра объекта. Его основная задача — инициализировать состояние объекта.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Какое отличие между статическим и нестатическим методом?',
    a: 'Статический метод принадлежит классу и вызывается без создания объекта. Нестатический (экземплярный) требует создания объекта, так как оперирует его состоянием.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое перегрузка методов (method overloading)?',
    a: 'Перегрузка — это определение нескольких методов с одним именем, но разными параметрами. Отличается от переопределения (override), которое касается наследования.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое переопределение метода (method overriding)?',
    a: 'Переопределение метода — это реализация метода родительского класса в подклассе с тем же именем и сигнатурой. Используется для изменения поведения.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое принцип "Программирование через интерфейсы"?',
    a: 'Означает, что модули должны зависеть от абстракций (интерфейсов или абстрактных классов), а не от конкретных классов-реализаций.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое SOLID?',
    a: 'SOLID — это набор принципов объектно-ориентированного проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Какие плюсы и минусы множественного наследования?',
    a: '''

Множественное наследование — это возможность класса наследовать функциональность от нескольких родительских классов одновременно.

Плюсы:
- Повторное использование кода:
  - Можно комбинировать функциональность разных классов
  - Избежание дублирования кода

- Гибкость моделирования:
  - Более точное отражение реальных отношений
  - Объект может "быть" несколькими вещами одновременно


Минусы:
- Проблема "ромба"
class A {
  void method() => print('A');
}

class B extends A {
  void method() => print('B');
}

class C extends A {
  void method() => print('C');
}

class D extends B, C {
  void method() => print('D');
} // Какой method() вызвать?

Сложность:
- Усложнение иерархии классов
- Трудности в понимании и отладке
- Конфликты имен методов/полей
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое виртуальные методы?',
    a: 'Это методы, которые могут быть переопределены в дочернем классе. Он определяется в базовом классе и позволяет обеспечить полиморфизм.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Как работает полиморфизм при передаче объектов в метод?',
    a: 'Если метод принимает параметр базового типа, можно передать объект производного класса. Вызов метода будет полиморфным — зависит от реального типа объекта.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое абстракция?',
    a: '''
Абстракция — это принцип, при котором выделяются только значимые характеристики объекта, скрывая ненужные детали реализации.
Абстракция позволяет сосредоточиться на том, что объект делает, а не на том, как он это делает.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое полиморфизм в ООП?',
    a: 'Полиморфизм — это способность объектов разных классов обрабатывать вызов одного и того же метода по-разному. Он позволяет использовать единый интерфейс для разных типов объектов.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'В чём разница между переопределением (overriding) и перегрузкой (overloading)?',
    a: 'Переопределение — это изменение реализации метода в наследнике при той же сигнатуре. Перегрузка — это определение нескольких методов с одинаковым именем, но разными параметрами, в одном классе.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое наследование?',
    a: '''
Позволяет создать новый класс на основе уже существующего. Дочерний класс (subclass) заимствует поля и методы родительского класса (superclass), что позволяет строить иерархии объектов и повторно использовать код.

Принцип подстановки Лисков (Liskov Substitution Principle - L в SOLID): Если заменяем родителя на потомка, программа не должна "падать" или вести себя некорректно.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'В чём разница между наследованием и композицией?',
    a: r'''
Наследование — "is-a" отношение (напр. Dog is-an Animal). Изменение в родителе может случайно сломать всех потомков.

// Базовый класс
class Logger {
  void log(String message) {
    print('LOG: $message');
  }
}

// Наследник для записи в файл
class FileLogger extends Logger {
  @override
  void log(String message) {
    super.log(message); // Вызываем базовый метод
    print('Saving "$message" to file...');
  }
}

// Наследник для отправки в API
class ApiLogger extends Logger {
  @override
  void log(String message) {
    super.log(message);
    print('Sending "$message" to remote server...');
  }
}

Композиция — "has-a" (Car has-an Engine). Класс имет объект другого класса.

Композиция предпочтительнее, когда важно избегать жёсткой связности и упростить поддержку.

// 1. Абстракция для транспорта (способа записи)
abstract class LogTransport {
  void transfer(String message);
}

// 2. Конкретные реализации транспорта
class FileTransport implements LogTransport {
  @override
  void transfer(String message) => print('Saving "$message" to file...');
}

class ApiTransport implements LogTransport {
  @override
  void transfer(String message) => print('Sending "$message" to server...');
}

// 3. Основной класс Logger ТЕПЕРЬ ВКЛЮЧАЕТ в себя транспорт
class Logger {
  final List<LogTransport> _transports;

  Logger(this._transports); // Композиция: Logger состоит из транспортов

  void log(String message) {
    print('LOG: $message');
    for (var transport in _transports) {
      transport.transfer(message);
    }
  }
}

void main() {
  // Мы можем на лету собрать любой логгер!
  final logger = Logger([
    FileTransport(),
    ApiTransport(),
  ]);

  logger.log("App started");
}

''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Может ли дочерний класс иметь несколько родителей? Какие есть альтернативы множественному наследованию?',
    a: 'В большинстве языков ООП множественное наследование не поддерживается напрямую из-за проблем, как "ромбовидное наследование". Альтернатива — интерфейсы или mixins (в Dart, Python).',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое агрегация?',
    a: r'''
Агрегация — это тип отношений между классами «часть-целое», где часть может существовать независимо от целого.

Агрегация — это форма ассоциации, при которой один объект является частью другого, но сохраняет независимость.

Это «слабая» связь. Если мы удалим «целое» (родительский объект), «часть» (вложенный объект) останется жить и может быть использована в другом месте.

class Employee {
  final String name;
  Employee(this.name);
}

class Project {
  final String title;
  // Агрегация: проект содержит список сотрудников
  final List<Employee> team;

  Project(this.title, this.team);
}

void main() {
  // 1. Создаем сотрудника вне проекта (он существует сам по себе)
  final dev = Employee('Ivan');

  {
    // 2. Создаем проект и передаем туда сотрудника
    final mobileApp = Project('Super App', [dev]);
    print('Project ${mobileApp.title} started');
    // ... время жизни проекта заканчивается ...
  }

  // 3. Проект уничтожен, но объект 'dev' всё еще доступен!
  print('Employee ${dev.name} is still alive and looking for a new project.');
}
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип YAGNI?',
    a: '''
YAGNI (You Aren’t Gonna Need It) означает, что не стоит реализовывать функциональность до тех пор, пока в ней реально не возникнет необходимость. Это помогает избегать избыточной сложности и затрат.

Разработчик заранее пишет поддержку смены темы (светлая/темная), хотя в бэклоге нет задачи и дизайнеры этого не планировали. В итоге — лишний код, который не используется.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип KISS?',
    a: 'KISS (Keep It Simple, Stupid) — делай проще. Код должен быть как можно более простым, понятным и очевидным. Сложность — враг поддержки и сопровождения.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Почему "умный" (clever) код считается нарушением KISS?',
    a: 'Потому что он сложен для понимания другими разработчиками и для самого автора спустя время. Читаемость важнее краткости и трюков.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип DRY?',
    a: '''
DRY (Don’t Repeat Yourself) — не повторяйся. Повторение одного и того же кода ведёт к дублированию логики, ошибкам при обновлениях и усложнению поддержки.

Если при внесении одного изменения тебе приходится править код в нескольких местах — ты, скорее всего, нарушаешь DRY.

Когда именно стоит нарушить DRY:

1. Если два куска кода выглядят одинаково сейчас, это не значит, что они про одно и то же.

2. Если DRY требует создания сложной дженерик-логики с кучей флагов и условий внутри, лучше оставить дублирование.

3. Если ты разрабатываешь многомодульное приложение или пакетную архитектуру, иногда лучше скопировать небольшой вспомогательный класс (utility),
чем создавать зависимость одного модуля от другого ради 10 строк кода. Это уменьшает зацепление (coupling).
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип единой ответственности (Single Responsibility Principle)?',
    a: 'Каждый класс должен иметь только одну причину для изменения, то есть выполнять только одну задачу или отвечать за один аспект системы.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Как определить, нарушает ли класс принцип SRP?',
    a: 'Если класс выполняет более одной логической задачи или имеет несколько причин для изменения (например, и логика, и сохранение в базу), он нарушает SRP.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Почему нарушение SRP может привести к проблемам при сопровождении кода?',
    a: 'Изменение одной ответственности может повлиять на другие части класса, что увеличивает вероятность багов и делает код менее предсказуемым и трудно тестируемым.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип Open/Closed в SOLID?',
    a: '''
Код должен быть **открыт для расширения, но закрыт для изменения**. Это значит, что поведение модуля должно можно изменять, не меняя его исходный код — например, через наследование, делегирование, полиморфизм.

> OCP = можно расширять, нельзя трогать старое.
>
> Используйте **абстракции и полиморфизм**, чтобы добавлять новое поведение **без модификации** существующего кода.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Приведи пример нарушения принципа Open/Closed.',
    a: 'Если в классе есть условная логика вроде `if (type == ...)`, и при добавлении нового типа приходится модифицировать класс — это нарушение. Вместо этого лучше использовать полиморфизм и интерфейсы.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Почему соблюдение принципа Open/Closed важно при росте проекта?',
    a: 'Потому что позволяет безопасно добавлять новые фичи без риска сломать существующий код. Это повышает стабильность, тестируемость и снижает стоимость поддержки.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Можно ли строго соблюдать Open/Closed без абстракций? Почему?',
    a: 'Нет, без абстракций (интерфейсов, базовых классов) невозможно расширять поведение без модификации существующего кода. Абстракции — ключ к реализации этого принципа.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип подстановки Лисков (LSP)?',
    a: '''
Принцип о корректности наследования.

Если есть базовый класс и его подкласс, то подкласс должен работать так же, как и базовый класс, не нарушая ожиданий клиентского кода.
Подкласс не должен бросать исключения в местах, где базовый класс их не бросал

Пример: Класс Rectangle и подкласс Square.
Если Square переопределяет setWidth и setHeight так, что они всегда равны, поведение меняется и нарушается контракт родителя, который ожидал независимость сторон.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'В чём суть принципа Interface Segregation (разделения интерфейса)?',
    a: '''
Клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы должны быть маленькими и специфичными, а не "жирными".

Жирный интерфейс — это интерфейс с большим количеством методов, не все из которых нужны каждому пользователю. Это приводит к пустым реализациям, нарушениям SRP и усложнению кода.

Проблема: Классы вынуждены реализовывать ненужные методы, что усложняет поддержку, увеличивает связанность и делает систему хрупкой при изменениях.

Пример: аудио и видео плеер. у аудио плеера не нужен метод увеличить яркость.
    ''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое принцип инверсии зависимостей (Dependency Inversion Principle)?',
    a: '''
1. Модули верхнего уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций."
2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Нужен, чтобы обеспечить слабую связанность между компонентами. Это позволяет легко подменять реализации и внедрять зависимости через интерфейсы.

Для реализации Dependency Inversion можно внедрить зависимости через Dependency Injection через конструктор, провайдеры (например, Riverpod, Provider) или сервис-локаторы (GetIt).

Нарушение: класс напрямую создаёт зависимость:
`final repo = MyApiRepository();`.

Соблюдение: класс зависит от интерфейса:
`final Repository repo;` и получает его через DI.

Dependency Injection — это технический способ передать зависимость в объект.
Dependency Inversion — это архитектурный принцип, согласно которому код должен зависеть от абстракций. DI помогает реализовать DIP.
''',
  ),
];
