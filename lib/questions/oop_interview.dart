import '../model/qa_model.dart';

const List<QA> oopQuestions = [
  QA(
    tags: [Tag.oop],
    q: 'Что такое ООП и какие основные принципы оно включает?',
    a: 'ООП (объектно-ориентированное программирование) — парадигма, основанная на использовании объектов. Основные принципы: инкапсуляция, наследование, полиморфизм и абстракция.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое инкапсуляция?',
    a: '''
Две основные функции инкапсуляции:
1. Объединение данных и методов (Data Bundling)
2. Сокрытие данных и контроль доступа

Инкапсуляция реализуется с помощью модификаторов доступа (например, private, protected, public), геттеров и сеттеров, а также через ограничение прямого доступа к полям класса.
    ''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое наследование?',
    a: 'Наследование — это механизм, позволяющий создавать новый класс на основе существующего. Пример: class Dog extends Animal { ... }. Dog наследует все свойства и методы от Animal.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое полиморфизм?',
    a: 'Полиморфизм — это способность объектов разных классов обрабатывать вызовы одного и того же метода по-разному.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Можно ли создать экземпляр абстрактного класса?',
    a: 'Нет, абстрактные классы нельзя инстанцировать напрямую.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Чем отличаются класс и объект?',
    a: 'Класс — это шаблон (чертеж), описывающий структуру и поведение объектов. Объект — конкретный экземпляр класса, занимающий память и способный выполнять действия.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое конструктор?',
    a: 'это специальный метод класса, который автоматически вызывается при создании экземпляра объекта. Его основная задача — инициализировать состояние объекта.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Объясни отличие между статическим и нестатическим методом.',
    a: 'Статический метод принадлежит классу и вызывается без создания объекта. Нестатический (экземплярный) требует создания объекта, так как оперирует его состоянием.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое перегрузка методов (method overloading)?',
    a: 'Перегрузка — это определение нескольких методов с одним именем, но разными параметрами. Отличается от переопределения (override), которое касается наследования.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое переопределение метода (method overriding)?',
    a: 'Переопределение — это реализация метода родительского класса в подклассе с тем же именем и сигнатурой. Используется для изменения поведения.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Объясни принцип "Программирование через интерфейсы".',
    a: 'Это подход, при котором код работает с абстракциями (интерфейсами), а не с конкретными реализациями. Это повышает гибкость и расширяемость системы.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое SOLID?',
    a: 'SOLID — это набор принципов объектно-ориентированного проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое множественное наследование? В чем его плюсы и минусы?',
    a: '''

Множественное наследование — это возможность класса наследовать функциональность от нескольких родительских классов одновременно.

Плюсы:
- Повторное использование кода:
  - Можно комбинировать функциональность разных классов
  - Избежание дублирования кода

- Гибкость моделирования:
  - Более точное отражение реальных отношений
  - Объект может "быть" несколькими вещами одновременно


Минусы:
- Diamond Problem

// Проблема "ромба"
class A { void method() => print('A'); }
class B extends A { void method() => print('B'); }
class C extends A { void method() => print('C'); }
class D extends B, C { } // Какой method() вызвать?

Сложность:
- Усложнение иерархии классов
- Трудности в понимании и отладке
- Конфликты имен методов/полей

''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое виртуальные методы?',
    a: 'Это методы, которые могут быть переопределены в дочернем классе. Он определяется в базовом классе и позволяет обеспечить полиморфизм.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое final, const, immutable в контексте ООП?',
    a: 'Это способы обозначить неизменяемость. Final/const — для переменных. Immutable — про объекты, которые нельзя изменить после создания. Особенно важно для потокобезопасности и чистой архитектуры.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Как работает полиморфизм при передаче объектов в метод?',
    a: 'Если метод принимает параметр базового типа, можно передать объект производного класса. Вызов метода будет полиморфным — зависит от реального типа объекта.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое абстракция в объектно-ориентированном программировании?',
    a: '''
Абстракция в ООП — это принцип, при котором мы выделяем только значимые характеристики объекта, скрывая ненужные детали реализации.
Проще говоря, абстракция позволяет сосредоточиться на том, что объект делает, а не на том, как именно он это делает.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое полиморфизм в ООП?',
    a: 'Полиморфизм — это способность объектов разных классов обрабатывать вызов одного и того же метода по-разному. Он позволяет использовать единый интерфейс для разных типов объектов.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Зачем использовать полиморфизм в реальных проектах?',
    a: 'Для написания расширяемого, масштабируемого и легко сопровождаемого кода. Например, можно менять реализацию без изменения вызывающего кода, если используется интерфейс или базовый класс.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'В чём разница между переопределением (overriding) и перегрузкой (overloading)?',
    a: 'Переопределение — это изменение реализации метода в наследнике при той же сигнатуре. Перегрузка — это определение нескольких методов с одинаковым именем, но разными параметрами, в одном классе.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое наследование и зачем оно нужно в ООП?',
    a: 'Наследование позволяет одному классу (дочернему) унаследовать свойства и методы другого класса (родительского), чтобы переиспользовать код, расширять поведение и реализовывать полиморфизм.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'В чём разница между наследованием и композицией?',
    a: '''
Наследование — "is-a" отношение (напр. Dog is-an Animal). Композиция — "has-a" (Car has-an Engine). Композиция предпочтительнее, когда важно избегать жёсткой связности и упростить поддержку.
class Device {
  final AudioPlayer? audioPlayer;
  final VideoPlayer? videoPlayer;

  Device({
    bool hasAudioPlayer = false,
    bool hasVideoPlayer = false,
  }) : audioPlayer = hasAudioPlayer ? AudioPlayer() : null, // Создаем внутри
       videoPlayer = hasVideoPlayer ? VideoPlayer() : null;
}

// Использование
final device = Device(hasAudioPlayer: true); // Композиция

      ''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что произойдёт, если в дочернем классе определить метод с тем же именем, что и в родительском?',
    a: 'Будет происходить переопределение метода (override), и при вызове будет использоваться реализация дочернего класса — если доступ идёт через реальный тип объекта.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Может ли дочерний класс иметь несколько родителей? Какие есть альтернативы множественному наследованию?',
    a: 'В большинстве языков ООП множественное наследование не поддерживается напрямую из-за проблем, как "ромбовидное наследование". Альтернатива — интерфейсы или mixins (в Dart, Python).',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Нужно ли вызывать конструктор родителя явно при наследовании? Почему это важно?',
    a: 'Да, особенно если у родителя есть нестандартный (не default) конструктор. Конструктор родителя должен быть вызван из дочернего класса для корректной инициализации.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Что такое?',
    a: '''
Агрегация — это тип композиции, где объекты существуют независимо друг от друга, но один объект использует другой.
Связь более слабая: если "владелец" уничтожается, "часть" может продолжать существовать.

'Пример: класс Team содержит список объектов Player, но Player может существовать и вне Team. Это агрегация.',
''',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип YAGNI и в чем его основная идея?',
    a: 'YAGNI (You Aren’t Gonna Need It) означает, что не стоит реализовывать функциональность до тех пор, пока в ней реально не возникнет необходимость. Это помогает избегать избыточной сложности и затрат.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Какое последствие может быть у нарушения принципа YAGNI?',
    a: 'Кодовая база разрастается, усложняется поддержка, возрастает технический долг и повышается риск внедрения багов в неиспользуемую функциональность.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Приведи пример нарушения YAGNI в реальном проекте.',
    a: 'Разработчик заранее пишет поддержку смены темы (светлая/темная), хотя в бэклоге нет задачи и дизайнеры этого не планировали. В итоге — лишний код, который не используется.',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип KISS?',
    a: 'KISS (Keep It Simple, Stupid) — делай проще. Код должен быть как можно более простым, понятным и очевидным. Сложность — враг поддержки и сопровождения.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Почему "умный" (clever) код считается нарушением KISS?',
    a: 'Потому что он сложен для понимания другими разработчиками и для самого автора спустя время. Читаемость важнее краткости и трюков.',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип DRY и зачем он нужен?',
    a: 'DRY (Don’t Repeat Yourself) — не повторяйся. Повторение одного и того же кода ведёт к дублированию логики, ошибкам при обновлениях и усложнению поддержки.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Как понять, что ты нарушаешь DRY?',
    a: 'Если при внесении одного изменения тебе приходится править код в нескольких местах — ты, скорее всего, нарушаешь DRY.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Всегда ли нужно строго следовать DRY?',
    a: 'Нет. Иногда лучше **скопировать и вставить** (особенно в ранней фазе разработки), чем преждевременно обобщать код и усложнять его. DRY не должен нарушать KISS и YAGNI.',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип единственной ответственности (Single Responsibility Principle)?',
    a: 'Каждый класс должен иметь только одну причину для изменения, то есть выполнять только одну задачу или отвечать за один аспект системы.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Как определить, нарушает ли класс принцип SRP?',
    a: 'Если класс выполняет более одной логической задачи или имеет несколько причин для изменения (например, и логика, и сохранение в базу), он нарушает SRP.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Почему нарушение SRP может привести к проблемам при сопровождении кода?',
    a: 'Изменение одной ответственности может повлиять на другие части класса, что увеличивает вероятность багов и делает код менее предсказуемым и трудно тестируемым.',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип Open/Closed в SOLID?',
    a: '''
Код должен быть **открыт для расширения, но закрыт для изменения**. Это значит, что поведение модуля должно можно изменять, не меняя его исходный код — например, через наследование, делегирование, полиморфизм.

> OCP = можно расширять, нельзя трогать старое.
>
> Используйте **абстракции и полиморфизм**, чтобы добавлять новое поведение **без модификации** существующего кода.
''',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Приведи пример нарушения принципа Open/Closed.',
    a: 'Если в классе есть условная логика вроде `if (type == ...)`, и при добавлении нового типа приходится модифицировать класс — это нарушение. Вместо этого лучше использовать полиморфизм и интерфейсы.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Почему соблюдение принципа Open/Closed важно при росте проекта?',
    a: 'Потому что позволяет безопасно добавлять новые фичи без риска сломать существующий код. Это повышает стабильность, тестируемость и снижает стоимость поддержки.',
  ),
  QA(
    tags: [Tag.oop],
    q: 'Можно ли строго соблюдать Open/Closed без абстракций? Почему?',
    a: 'Нет, без абстракций (интерфейсов, базовых классов) невозможно расширять поведение без модификации существующего кода. Абстракции — ключ к реализации этого принципа.',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что означает принцип подстановки Лисков (LSP)?',
    a: '''
Принцип о корректности наследования.

Если есть базовый класс и его подкласс, то подкласс должен работать так же, как и базовый класс, не нарушая ожиданий клиентского кода\nПодкласс не должен бросать исключения в местах, где базовый класс их не бросал

Класс Rectangle и подкласс Square. Если Square переопределяет setWidth и setHeight так, что они всегда равны, поведение меняется и нарушается контракт родителя, который ожидал независимость сторон.

''',
  ),

  QA(
    tags: [Tag.oop],
    q: 'В чём суть принципа Interface Segregation (разделения интерфейса)?',
    a: '''
Клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы должны быть маленькими и специфичными, а не "жирными".

Жирный” интерфейс — это интерфейс с большим количеством методов, не все из которых нужны каждому пользователю. Это приводит к пустым реализациям, нарушениям SRP и усложнению кода.

Проблема: Классы вынуждены реализовывать ненужные методы, что усложняет поддержку, увеличивает связанность и делает систему хрупкой при изменениях.

Пример: аудио и видео плеер. у аудио плеера не нужен метод увеличить яркость.
    ''',
  ),

  QA(
    tags: [Tag.oop],
    q: 'Что такое принцип инверсии зависимостей (Dependency Inversion Principle)?',
    a: '''
> "Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций."
>
> "Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций."

Нужен, чтобы обеспечить слабую связанность между компонентами. Это позволяет легко подменять реализации и внедрять зависимости через интерфейсы.

Для реализации Dependency Inversion можно внедрить зависимости через Dependency Injection через конструктор, провайдеры (например, Riverpod, Provider) или сервис-локаторы (GetIt).

Нарушение: класс напрямую создаёт зависимость:
`final repo = MyApiRepository();`.

Соблюдение: класс зависит от интерфейса:
`final Repository repo;` и получает его через DI.

Dependency Injection — это технический способ передать зависимость в объект.
Dependency Inversion — это архитектурный принцип, согласно которому код должен зависеть от абстракций. DI помогает реализовать DIP.
''',
  ),
];
